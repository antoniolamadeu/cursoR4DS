---
title: "Data Wrangling"
author: "Curso R"
date: "16 de setembro de 2017"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Pacotes

```{r}
library(tidyverse)
library(lubridate)
library(stringr)
```

## Importação 

### Excel

```{r}
# BD: excel com (.) como separador decimal
dados <- readxl::read_excel("../Aula 1/data/bdc.xls", na = c("", "NT", "NA"))

str(dados)
```

```{r, message=FALSe, error=FALSE, warning=FALSE}
# Colocando o tipo das variáveis na mão
dados <- readxl::read_excel("../Aula 1/data/bdc.xls",
na = c("", "NT", "NA"),
col_types = c("text",
"date",
"guess",
"date",
"text",
rep("numeric", 4),
"text",
rep("numeric", 2),
"text",
rep("numeric", 2),
"text",
"text"))
```

### CSV

```{r}
# BD: csv com (;) e (,) como separador decimal
dados <- readr::read_csv2("../Aula 1/data/bdc.csv",
na = c("", "NT", "NA"))
```

### TAB Delim

```{r}
# BD: texto delimitado por tabulação
dados <- readr::read_delim("../Aula 1/data/bdc.txt", delim = "\t")
```

### SQL

```{r, eval = FALSE}
# Criar um banco de dados SQLite

mydb <- dbConnect(RSQLite::SQLite(), "my-db.sqlite")

dbWriteTable(mydb, "mtcars", mtcars)
dbGetQuery(mydb, 'SELECT * FROM mtcars LIMIT 5')
dbGetQuery(mydb, 'select * from mtcars where drat > 4')
```

# Mais opções

- https://github.com/rstats-db
- http://db.rstudio.com/

```{r, eval = FALSE}
con <- dbConnect(odbc::odbc(),
                 Driver   = "[your driver's name]",
                 Server   = "[your server's path]",
                 Database = "[your database's name]",
                 UID      = rstudioapi::askForPassword("Database user"),
                 PWD      = rstudioapi::askForPassword("Database password"),
                 Port     = 1433)
## Data wrangling
```

## Data Wrangling

```{r, echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/hadley/r4ds/master/diagrams/data-science.png")
```

### Exercício 

Carregue o conteúdo do arquivo `data/infos_processos.rds` num objeto chamado `d_infos`.

Dica: O pacote `readr` tem uma ampla gama de funções para importação de dados.







```{r}
d_infos <- readr::read_rds("data/infos_processos.rds")
```

```{r, eval = FALSE}
dataset <- readr::read_rds("data/d_cposg.rds")

informacoes <- dataset %>% 
  select(id, data) %>% 
  unnest(data) %>% 
  spread(data, value) %>% 
  janitor::clean_names() %>% 
  abjutils::rm_accent_from_names()

decisoes <- dataset %>% 
  select(id, decisions) %>% 
  unnest(decisions) %>% 
  group_by(id) %>%
  filter(date == max(date))

movs <- dataset %>% 
  select(id, movs) %>% 
  unnest(movs) %>% 
  mutate(movement = format(movement, "%d/%m/%Y"))
  #group_by(id) %>% 
  #Wsummarise(data_dist = min(movement))

processos <- readRDS("../Aula 1/data/processos_pra_pegar.rds")

d_infos <- informacoes %>% 
  inner_join(decisoes) %>% 
  #inner_join(movs) %>% 
  filter(area == "Criminal",
         id %in% processos,
         !distribuicao %in% c("5ª Câmara de Direito Criminal D", "Órgão Especial"),
         situacao %in% c("Encerrado", "Julgado", "Transitado")
         # Tiramos o "administrativamente" porque são casos em que não há julgamento do mérito
         ) %>% 
  select(-x, -outros_numeros, -numeros_de_origem, -processo, -ultima_carga, -volume_apenso) %>% 
  rename(data_ultima_decisao = date,
         decisao = decision) %>% 
  mutate(data_ultima_decisao = format(data_ultima_decisao, "%d/%m/%Y")
         #data_dist = format(data_dist, "%d/%m/%Y")
  )

saveRDS(d_infos, 'data/infos_processos.rds')
saveRDS(movs,  'data/movs_processos.rds')
```

### Diagnóstico das variáveis

```{r}
glimpse(d_infos)
```

```{r}
library(Hmisc)
describe(d_infos) 

# devtools::install_github("ropenscilabs/skimr") 
# meio chato de instalar por enquanto!
library(skimr)
skim(d_infos)
```

## Arrumando a casa

- Algumas variáveis contém muita informação bruta, que não está no melhor formato possível

### Assunto

- Existem três níveis de assunto do processo que estão codificadas na coluna assunto

```{r}
d_infos %>% 
  count(assunto)
```

```{r}
d_infos <- d_infos %>% 
  separate(
    col = assunto, 
    into = c("assunto_geral", "assunto_intermediario", "assunto"), 
    sep = "-", 
    extra = 'merge', 
    fill = 'right'
  )
```

```{r}
d_infos %>% 
  count(assunto_geral)
# Por que o mesmo assunto aparece duas vezes? Descubram!

d_infos %>% 
  count(assunto_intermediario)
# Por que o mesmo assunto aparece duas vezes? Descubram!

d_infos %>% 
  count(assunto)
# Por que o mesmo assunto aparece duas vezes? Descubram!

```

Tirando espaços indevidos:

```{r}
d_infos <- d_infos %>% 
  mutate(
    assunto_geral = str_trim(assunto_geral),
    assunto_intermediario = str_trim(assunto_intermediario),
    assunto = str_trim(assunto)
  )
```

## Comarca

```{r}
d_infos %>% 
  count(distribuicao)
# Existem subgrupos de câmaras que queremos agrupar
```

```{r}
# Vamos criar novas variáveis
d_infos <- d_infos %>% 
  mutate(extraordinaria = str_detect(distribuicao, "Extraordinária"),
         grupo = str_detect(distribuicao, "Grupo"))
```

```{r}
d_infos %>% 
  count(grupo)

d_infos %>% 
  count(extraordinaria)
```

## Exercício 

Separe a coluna "origem" em quantos pedaços for necessário.

Dica: Existe uma função no pacote `tidyr` que faz isso.









```{r}
d_infos <- d_infos %>%
  separate(col = origem,
                  into = c("Comarca", "Foro", "Vara"),
                  sep = " / ")

d_infos %>%
  count(Comarca, sort = TRUE)

d_infos %>%
  count(Foro, sort = TRUE)

d_infos %>%
  count(Vara, sort = TRUE)
```

## Joins

```{r}
d_movs <- readRDS("../Aula 1/data/movs_processos.rds")
```

```{r}
datas_de_distribuicao <- d_movs %>% 
  mutate(movement = dmy(movement)) %>% 
  group_by(id) %>% 
  summarise(data_dist = min(movement))
```

```{r}
d_infos <- d_infos %>% 
  inner_join(datas_de_distribuicao)

# equivalente a explicitamente adicionar o `by`.
# d_infos <- d_infos %>% 
#   inner_join(datas_de_distribuicao, by = "id")
```


## Datas

```{r}
library(lubridate)

d_infos <- d_infos %>% 
  mutate(dia_dist = day(data_dist),
         mes_dist = month(data_dist),
         ano_dist = year(data_dist))
```

## Exercício

1) Criar a variável duração do processo.






```{r}
d_infos <- d_infos %>%
  mutate(duracao = dmy(data_ultima_decisao) - data_dist,
         duracao = as.numeric(duracao))


# ou usar o seguinte:
d_infos <- d_infos %>%
  mutate(
    duracao = difftime(data_ultima_decisao, data_dist, units = "days"),
    duracao = as.numeric(duracao)
    )
# 
# units = c("auto", "secs", "mins", "hours",
#                    "days", "weeks")

```

2) Fazer um gráfico da quantidade de decisões por dia











```{r}
d_infos %>%
  group_by(data_ultima_decisao) %>%
  summarise(qtd = n()) %>%
  ggplot(aes(x = dmy(data_ultima_decisao), y = qtd)) +
  geom_line() +
  scale_x_date(limits = dmy(c("01-10-2016", "01-01-2017")))
```

3) Qual é o dia da semana com mais distribuições? Faça um gráfico. Dica: Veja as funções do 
lubridate.














```{r}
d_infos %>%
  mutate(dia_da_semana = wday(data_dist, label = TRUE)) %>%
  ggplot() + 
  geom_bar(aes(x = dia_da_semana))
```


## Construíndo a variável resposta

O R básico não tem uma sintaxe consistente para trabalhar com textos.
O pacote `stringr` ajuda a realizar todas as tarefas básicas de manipulação de texto,
exigindo que o usuário estude apenas uma sintaxe.
O `stringr` também é construído sobre a [biblioteca ICU](http://site.icu-project.org/),
implementada em `C` e `C++`, 
apresentando resultados rápidos e confiáveis.

As regras básicas do pacote são:

- As funções de manipulação de texto começam com `str_`. Caso esqueça o nome de uma função, basta digitar `stringr::str_` e apertar `TAB` para ver quais são as opções.
- O primeiro argumento da função é sempre uma `string`.

Antes de listar as funções, 
precisamos estudar o básico de 
expressões regulares.

### Expressões regulares

Expressão regular ou *regex* é uma sequência concisa de caracteres que representa várias strings. Entender o básico de expressões regulares é indispensável para trabalhar com textos.

Vamos estudar expressões regulares através de exemplos e com a função `str_detect()`. Essa função retorna `TRUE` se uma string atende à uma expressão regular e `FALSE` em caso contrário.

A tabela abaixo mostra a aplicação de seis `regex` a seis strings distintas.

```{r}
library(stringr)
testes <- c('ban', 'banana', 'abandonado', 'pranab anderson', 'BANANA', 'ele levou ban')

expressoes <- list(
  'ban', # reconhece tudo que tenha "ban", mas não ignora case
  'BAN', # reconhece tudo que tenha "BAN", mas não ignora case
  regex('ban', ignore_case = TRUE), # reconhece tudo que tenha "ban", ignorando case
  'ban$', # reconhece apenas o que termina exatamente em "ban"
  '^ban', # reconhece apenas o que começa exatamente com "ban"
  'b ?an' # reconhece tudo que tenha "ban", com ou sem espaço entre o "b" e o "a"
)
```

```{r echo=FALSE}
purrr::map(testes, ~str_detect(testes, .x)) %>% 
  {do.call(rbind, .)} %>% 
  as.data.frame() %>% 
  setNames(testes) %>% 
  dplyr::mutate(regex = expressoes) %>% 
  dplyr::select(regex, dplyr::everything()) %>% 
  knitr::kable()
```

### Insumo da variável resposta

- Três resultados possíveis: provido, parcialmente provido, improvido
- A votação pode ser unânime (V.U.) ou não 

```{r}
#Começando do mais fácil

d_infos <- d_infos %>% 
  mutate(voto_unanime = str_detect(decisao, "V\\.U\\."))
```

```{r}
# Essa é uma regex ruim!

d_infos %>% 
  filter(!voto_unanime) %>%
  View
```

```{r}
d_infos <- d_infos %>% 
  mutate(voto_unanime = str_detect(decisao, regex("V\\.? ?U\\.?", ignore_case = T)))
```

```{r}
# Ainda não funcionou! Olhe a linha 10.
d_infos %>% 
  filter(!voto_unanime) %>%
  View
```

```{r}
d_infos <- d_infos %>% 
  mutate(voto_unanime = str_detect(decisao, regex("unanim|V\\.? ?U\\.?", ignore_case = T)))
```

```{r}
# Ainda não funcionou! Olhe a linha 17.
d_infos %>% 
  filter(!voto_unanime) %>%
  View
```

```{r}
d_infos <- d_infos %>% 
  mutate(decisao = rslp:::remove_accents(decisao), 
    voto_unanime = str_detect(decisao, regex("unanim|V\\.? ?U\\.?", ignore_case = T)))
```

```{r}
d_infos %>% 
  filter(!voto_unanime) %>%
  View
```


### Parte mais complicada

```{r}
regex_parcialmente_provido <- "parcial provimento"
regex_provido <- "recurso provido"
regex_nao_provido <- "negaram provimento"

d_infos <- d_infos %>% 
  mutate(decisao = stringr::str_to_lower(decisao),
         decisao = rslp:::remove_accents(decisao), 
         resultado = case_when(
           stringr::str_detect(decisao, regex_parcialmente_provido) ~ "Parcialmente Provido",
           stringr::str_detect(decisao, regex_provido) ~ "Provido",
           stringr::str_detect(decisao, regex_nao_provido) ~ "Improvido",
           TRUE ~ "Outros"
         ))
```

```{r}
d_infos %>% 
  count(resultado)
```

## Exercício

Aprimore as regex acima para diminuir a proporção de casos classificados como "Outros". Uma proporção menor do que 20% é aceitável.

Dica: Explore a coluna `decisao` nos casos em que a regex acima classifcou como "Outros".

















### Solução 1

```{r}
regex_parcialmente_provido <- "parcial provimento|provimento em parte|provimento parcial"
regex_provido <- "recurso provido|^deram provimento"
regex_nao_provido <- "negaram provimento|nega-se provimento"

d_infos <- d_infos %>%
  mutate(decisao = stringr::str_to_lower(decisao),
         decisao = rslp:::remove_accents(decisao),
         resultado = case_when(
           stringr::str_detect(decisao, regex_parcialmente_provido) ~ "Parcialmente Provido",
           stringr::str_detect(decisao, regex_provido) ~ "Provido",
           stringr::str_detect(decisao, regex_nao_provido) ~ "Improvido",
           TRUE ~ "Outros"
         ))
```





```{r}
regex_parcialmente_provido <- "parcial provimento|provimento em parte|provimento parcial"
regex_provido <- "recurso provido|deram provimento (ao|a)|mantiveram o|recursos?( e remessas?( necessaria)? ?)? conhecidos e providos"
regex_nao_provido <- "rejeitaram os embargos|julgaram prejudicado|negaram provimento|nao conheceram|nao providos?"
regex_nao_conheceram <- "nao conheceram"

d_infos <- d_infos %>% 
  mutate(decisao = stringr::str_to_lower(decisao),
         decisao = rslp:::remove_accents(decisao), 
         resultado = case_when(
           stringr::str_detect(decisao, regex_parcialmente_provido) ~ "Parcialmente Provido",
           stringr::str_detect(decisao, regex_provido) ~ "Provido",
           stringr::str_detect(decisao, regex_nao_provido) ~ "Improvido",
           stringr::str_detect(decisao, regex_nao_conheceram) ~ "Não Conheceram",
           TRUE ~ "Outros"
         ),
         decisao_binaria = ifelse(resultado == "Improvido", "Improvido", "Provido"))
```


```{r}
d_infos %>% 
  filter(resultado == "Outros") %>% 
  View
```

## Análises descritivas das explicativas versus a resposta

```{r}
d_infos %>% 
  count(decisao_binaria, assunto_geral) %>% 
  mutate(assunto_geral = str_wrap(assunto_geral, 15)) %>%
  ggplot(aes(y = n, x = assunto_geral, fill = decisao_binaria)) +
  geom_bar(stat = 'identity', position = 'fill')
```

```{r}
d_infos %>% 
    count(decisao_binaria, extraordinaria) %>% 
    ggplot(aes(y = n, x = extraordinaria,
               fill = decisao_binaria)) +
    geom_bar(stat = 'identity', position = 'fill')
```

```{r}
d_infos %>%
  mutate(duracao = dmy(data_ultima_decisao) - data_dist,
         duracao = as.numeric(duracao),
         duracao = cut(duracao, breaks = 10, include.lowest = T, dig.lab = 3)) %>% 
  count(decisao_binaria, duracao) %>% 
  ggplot(aes(y = n, x = duracao, fill = decisao_binaria)) +
  geom_bar(stat = 'identity', position = 'fill') +
  theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
```

```{r}
d_infos %>%
  ggplot(aes(x = duracao, fill = decisao_binaria)) +
  geom_density(alpha = 0.5) +
  coord_cartesian(xlim=c(0, 1000)) 
  #+ facet_wrap(~decisao_binaria)
```



```{r}
# visualizar os assuntos com maior quantidade de resultados 
# positivos
d_infos %>%
  mutate(assunto = assunto %>% as.factor() %>% fct_lump(n = 10)) %>%
  group_by(assunto) %>%
  summarise(
    qtd_processos = n(),
    perc_provido = mean(decisao_binaria == "Provido")
  ) %>%
  mutate(assunto = assunto %>% str_wrap(width = 20) %>% fct_reorder(perc_provido)) %>%
  gather(var, valor, -assunto) %>%
  ggplot(aes(x = assunto, y = valor)) + 
  geom_col() + 
  facet_wrap(~var, scales = "free", ncol = 1)
```





