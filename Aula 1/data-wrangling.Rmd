---
title: "Data Wrangling"
author: "Curso R"
date: "16 de setembro de 2017"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Pacotes

```{r, message=FALSE}
library(tidyverse)
library(lubridate)
library(stringr)
```

## Importação 

### Excel

```{r}
# BD: excel com (.) como separador decimal
dados <- readxl::read_excel("../Aula 1/data/bdc.xls", na = c("", "NT", "NA"))

str(dados)
```

```{r, message=FALSe, error=FALSE, warning=FALSE}
# Colocando o tipo das variáveis na mão
dados <- readxl::read_excel("../Aula 1/data/bdc.xls",
                            na = c("", "NT", "NA"),
                            col_types = c("text",
                                          "date",
                                          "guess",
                                          "date",
                                          "text",
                                          rep("numeric", 4),
                                          "text",
                                          rep("numeric", 2),
                                          "text",
                                          rep("numeric", 2),
                                          "text",
                                          "text"))
```

### CSV

```{r}
# BD: csv com (;) e (,) como separador decimal
dados <- readr::read_csv2("../Aula 1/data/bdc.csv", 
                          na = c("", "NT", "NA"),
                          locale = locale(encoding = "utf-8"))
names(dados)
```

### TAB Delim

```{r}
# BD: texto delimitado por tabulação
dados <- readr::read_delim("../Aula 1/data/bdc.txt", delim = "\t")
```

### SQL

```{r, eval = FALSE}
# Criar um banco de dados SQLite

mydb <- DBI::dbConnect(RSQLite::SQLite(), "my-db.sqlite")

DBI::dbWriteTable(mydb, "mtcars", mtcars, overwrite = TRUE)
DBI::dbGetQuery(mydb, 'SELECT * FROM mtcars LIMIT 5')
DBI::dbGetQuery(mydb, 'select * from mtcars where drat > 4')
```



# Mais opções

- https://github.com/rstats-db
- http://db.rstudio.com/

```{r, eval = FALSE}
con <- dbConnect(odbc::odbc(),
                 Driver   = "[your driver's name]",
                 Server   = "[your server's path]",
                 Database = "[your database's name]",
                 UID      = rstudioapi::askForPassword("Database user"),
                 PWD      = rstudioapi::askForPassword("Database password"),
                 Port     = 1433)

# MySQL
# SQLServer
# Oracle
# MongoDB
# Cassandra
# etc
```






### Exercício 

1) Carregue o conteúdo do arquivo `data/infos_processos.rds` num objeto chamado `d_infos`.
2) Carregue o conteúdo do arquivo `data/movs_processos.rds` num objeto chamado `d_movs`.

Dica: O pacote `readr` tem uma ampla gama de funções para importação de dados. escreva `readr::` no console a pressione TAB.


```{r}

```

















```{r}
d_infos <- readr::read_rds("data/infos_processos.rds")
d_movs <- readr::read_rds("data/movs_processos.rds")
```


## Manipulação de dados (Data Wrangling)

```{r, echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/hadley/r4ds/master/diagrams/data-science.png")
```


### Sobre o Banco de dados

```{r}
dim(d_infos)
names(d_infos)
glimpse(d_infos)
View(d_infos)

dim(d_movs)
names(d_movs)
glimpse(d_movs)
View(d_movs)
```

```{r, message = FALSE}
library(Hmisc)
describe(d_infos) 

# devtools::install_github("ropenscilabs/skimr") 
# meio chato de instalar por enquanto!
library(skimr)
skim(d_infos)
skim(d_movs)
```


### Diagnóstico das variáveis

```{r}
status <- function(data) {
 n <- data %>% map_dbl(length)
 n_distintos <- data %>% map_dbl(n_distinct)
 n_branco <- data %>% map_dbl(~ sum(str_detect(.x, "^ *$"), na.rm = TRUE))
 n_na <- data %>% map_dbl(~ sum(.x %in% c(NA, ".", "null"), na.rm = TRUE))
 n_zero <- data %>% map_dbl(~ sum(.x %in% 0, na.rm = TRUE))
 classe <- data %>% map_chr(~ class(.x)[1])
 tem_caracteres_estranhos <- data %>% map_lgl(~ any(str_detect(.x, "[^[:print:]]"), na.rm = TRUE))
 maximo_de_caracteres <- data %>% map_dbl(~ max(str_length(.x), na.rm = TRUE))
 
 resp <- data.frame(n,
                    n_distintos,
                    n_branco,
                    n_na,
                    n_zero,
                    classe,
                    tem_caracteres_estranhos,
                    maximo_de_caracteres) %>%
   rownames_to_column("variavel")
 return(resp)
}

d_infos %>% status
d_movs %>% status


# vocabulário
# - map_dbl/map_chr/map_lgl (pacote 'purrr')
# - n_distinct/length
# - str_detect/str_length/regex (pacote stringr)
```


## Arrumando a casa

- Algumas variáveis contém muita informação bruta, que não está no melhor formato possível

### Assunto

- Existem três níveis de assunto do processo que estão codificadas na coluna assunto

```{r}
d_infos %>% 
  count(assunto)
```

```{r}
d_infos <- d_infos %>% 
  separate(
    col = assunto, 
    into = c("assunto_geral", "assunto_intermediario", "assunto"), 
    sep = "-", 
    extra = 'merge', 
    fill = 'right'
  )
```

```{r}
d_infos %>% 
  count(assunto_geral)
# Por que o mesmo assunto aparece duas vezes? Descubram!

d_infos %>% 
  count(assunto_intermediario)
# Por que o mesmo assunto aparece duas vezes? Descubram!

d_infos %>% 
  count(assunto)
# Por que o mesmo assunto aparece duas vezes? Descubram!

```


















Tirando espaços indevidos:

```{r}
d_infos <- d_infos %>% 
  mutate(
    assunto_geral = str_trim(assunto_geral),
    assunto_intermediario = str_trim(assunto_intermediario),
    assunto = str_trim(assunto)
  )

```

## Comarca

```{r}
d_infos %>% 
  count(distribuicao)
# Existem subgrupos de câmaras que queremos agrupar
```

```{r}
# Vamos criar novas variáveis
d_infos <- d_infos %>% 
  mutate(extraordinaria = str_detect(distribuicao, "Extraordinária"),
         grupo = case_when(str_detect(distribuicao, "Grupo") ~ "Grupo",
                           str_detect(distribuicao, "Câmara") ~ "Câmara",
                           TRUE ~ "Outro"))
```

```{r}
d_infos %>% 
  count(grupo)

d_infos %>% 
  count(extraordinaria)


# Vocabulário
# - separate (tidyr)
# - mutate (dplyr)
# - case_when (dplyr)
# - str_trim (stringr)
```

## Exercício 

Separe a coluna "origem" em quantas colunas forem necessários.

Dica: não se preocupe em dar o nome correto às colunas por enquanto.






















```{r}
d_infos <- d_infos %>%
  separate(col = origem,
                  into = c("Comarca", "Foro", "Vara"),
                  sep = " / ")

d_infos %>%
  count(Comarca, sort = TRUE)

d_infos %>%
  count(Foro, sort = TRUE)

d_infos %>%
  count(Vara, sort = TRUE)
```

## Joins


```{r, echo=FALSE}
knitr::include_graphics("sql_vs_dplyr.png")
```


```{r}
d_movs <- readRDS("../Aula 1/data/movs_processos.rds")
```

```{r}
# ponto importante aqui: group_by + summarise
datas_de_distribuicao <- d_movs %>% 
  mutate(movement = dmy(movement)) %>% 
  group_by(id) %>% 
  summarise(data_de_distribuicao = min(movement))




# só uma parênteses aqui.... vamos falar sobre 'arrange' e 'first'
datas_de_distribuicao2 <- d_movs %>% 
  mutate(movement = dmy(movement)) %>% 
  group_by(id) %>% 
  arrange(movement) %>%
  summarise(data_de_distribuicao = first(movement)) # <- alternativa

teste <- datas_de_distribuicao %>%
  inner_join(datas_de_distribuicao2, by = "id") %>%
  mutate(igual = data_de_distribuicao.x == data_de_distribuicao.y) 

teste %>% View

teste %>% filter(!igual)
```

```{r}
d_infos <- d_infos %>% 
  inner_join(datas_de_distribuicao)

# equivalente a explicitamente adicionar o `by`.
# d_infos <- d_infos %>% 
#   inner_join(datas_de_distribuicao, by = "id")
names(datas_de_distribuicao)
names(d_infos)
```


## Datas

```{r}
library(lubridate)

d_infos <- d_infos %>% 
  mutate(dia_distribuicao = day(data_de_distribuicao),
         mes_distribuicao = month(data_de_distribuicao),
         ano_distribuicao = year(data_de_distribuicao))

glimpse(d_infos)
```

## Exercício

1) Criar a variável duração do processo.




















```{r}
d_infos <- d_infos %>%
  mutate(duracao = dmy(data_da_ultima_decisao) - data_de_distribuicao,
         duracao = as.numeric(duracao))


# ou usar o seguinte:
d_infos <- d_infos %>%
  mutate(
    duracao = difftime(data_da_ultima_decisao, data_de_distribuicao, units = "days"),
    duracao = as.numeric(duracao)
    )
# 
# units = c("auto", "secs", "mins", "hours",
#                    "days", "weeks")

```

2) Fazer um gráfico da quantidade de decisões por dia

















```{r}
d_infos %>%
  group_by(data_da_ultima_decisao) %>%
  summarise(qtd = n()) %>%
  ggplot(aes(x = dmy(data_da_ultima_decisao), y = qtd)) +
  geom_col() +
  scale_x_date(limits = dmy(c("01-10-2016", "01-01-2017")))
```

3) Qual é o dia da semana com mais distribuições? Dica: Veja as funções do 
lubridate.














```{r}
d_infos %>%
  mutate(dia_da_semana = wday(data_de_distribuicao, label = TRUE)) %>%
  ggplot() + 
  geom_bar(aes(x = dia_da_semana))
```


## Construíndo a variável resposta

O R básico não tem uma sintaxe consistente para trabalhar com textos.
O pacote `stringr` ajuda a realizar todas as tarefas básicas de manipulação de texto,
exigindo que o usuário estude apenas uma sintaxe.
O `stringr` também é construído sobre a [biblioteca ICU](http://site.icu-project.org/),
implementada em `C` e `C++`, 
apresentando resultados rápidos e confiáveis.

As regras básicas do pacote são:

- As funções de manipulação de texto começam com `str_`. Caso esqueça o nome de uma função, basta digitar `stringr::str_` e apertar `TAB` para ver quais são as opções.
- O primeiro argumento da função é sempre uma `string`.

Antes de listar as funções, 
precisamos estudar o básico de 
expressões regulares.

### Expressões regulares

Expressão regular ou *regex* é uma sequência concisa de caracteres que representa várias strings. Entender o básico de expressões regulares é indispensável para trabalhar com textos.

Vamos estudar expressões regulares através de exemplos e com a função `str_detect()`. Essa função retorna `TRUE` se uma string atende à uma expressão regular e `FALSE` em caso contrário.

A tabela abaixo mostra a aplicação de seis `regex` a seis strings distintas.

```{r}
library(stringr)
testes <- c('ban', 'banana', 'abandonado', 'pranab anderson', 'BANANA', 'ele levou ban')

expressoes <- list(
  'ban', # reconhece tudo que tenha "ban", mas não ignora case
  'BAN', # reconhece tudo que tenha "BAN", mas não ignora case
  regex('ban', ignore_case = TRUE), # reconhece tudo que tenha "ban", ignorando case
  'ban$', # reconhece apenas o que termina exatamente em "ban"
  '^ban', # reconhece apenas o que começa exatamente com "ban"
  'b ?an' # reconhece tudo que tenha "ban", com ou sem espaço entre o "b" e o "a"
)
```

```{r echo=FALSE}
purrr::map(testes, ~str_detect(testes, .x)) %>% 
  {do.call(rbind, .)} %>% 
  as.data.frame() %>% 
  setNames(testes) %>% 
  dplyr::mutate(regex = expressoes) %>% 
  dplyr::select(regex, dplyr::everything()) %>% 
  knitr::kable()
```

### Insumo da variável resposta

- Três resultados possíveis: provido, parcialmente provido, improvido
- A votação pode ser unânime (V.U.) ou não 

```{r}
#Começando do mais fácil

d_infos <- d_infos %>% 
  mutate(voto_unanime = str_detect(decisao, "V\\.U\\."))
```

```{r}
# Essa é uma regex ruim!

d_infos %>% 
  filter(!voto_unanime) %>%
  View
```

```{r}
d_infos <- d_infos %>% 
  mutate(voto_unanime = str_detect(decisao, regex("V\\.? ?U\\.?", ignore_case = T)))
```

```{r}
# Ainda não funcionou! Olhe a linha 10.
d_infos %>% 
  filter(!voto_unanime) %>%
  View
```

```{r}
d_infos <- d_infos %>% 
  mutate(voto_unanime = str_detect(decisao, regex("unanim|V\\.? ?U\\.?", ignore_case = T)))
```

```{r}
# Ainda não funcionou! Olhe a linha 17.
d_infos %>% 
  filter(!voto_unanime) %>%
  View
```

```{r}
d_infos <- d_infos %>% 
  mutate(decisao = rslp:::remove_accents(decisao), 
    voto_unanime = str_detect(decisao, regex("unanim|V\\.? ?U\\.?", ignore_case = T)))
```

```{r}
d_infos %>% 
  filter(!voto_unanime) %>%
  View
```


### Parte mais complicada

```{r}
regex_parcialmente_provido <- "parcial provimento"
regex_provido <- "recurso provido"
regex_nao_provido <- "negaram provimento"

d_infos <- d_infos %>% 
  mutate(decisao = stringr::str_to_lower(decisao),
         decisao = rslp:::remove_accents(decisao), 
         resultado = case_when(
           stringr::str_detect(decisao, regex_parcialmente_provido) ~ "Parcialmente Provido",
           stringr::str_detect(decisao, regex_provido) ~ "Provido",
           stringr::str_detect(decisao, regex_nao_provido) ~ "Improvido",
           TRUE ~ "Outros"
         ))
```

```{r}
d_infos %>% 
  count(resultado)
```

## Exercício

Aprimore as regex acima para diminuir a proporção de casos classificados como "Outros". Uma proporção menor do que 20% é aceitável.

Dica: Explore a coluna `decisao` nos casos em que a regex acima classifcou como "Outros".

















### Solução 1

```{r}
regex_parcialmente_provido <- "parcial provimento|provimento em parte|provimento parcial"
regex_provido <- "recurso provido|^deram provimento"
regex_nao_provido <- "negaram provimento|nega-se provimento"

d_infos <- d_infos %>%
  mutate(decisao = stringr::str_to_lower(decisao),
         decisao = rslp:::remove_accents(decisao),
         resultado = case_when(
           stringr::str_detect(decisao, regex_parcialmente_provido) ~ "Parcialmente Provido",
           stringr::str_detect(decisao, regex_provido) ~ "Provido",
           stringr::str_detect(decisao, regex_nao_provido) ~ "Improvido",
           TRUE ~ "Outros"
         ))
```





```{r}
regex_parcialmente_provido <- "parcial provimento|provimento em parte|provimento parcial"
regex_provido <- "recurso provido|deram provimento (ao|a)|mantiveram o|recursos?( e remessas?( necessaria)? ?)? conhecidos e providos"
regex_nao_provido <- "rejeitaram os embargos|julgaram prejudicado|negaram provimento|nao conheceram|nao providos?"
regex_nao_conheceram <- "nao conheceram"

d_infos <- d_infos %>% 
  mutate(decisao = stringr::str_to_lower(decisao),
         decisao = rslp:::remove_accents(decisao), 
         resultado = case_when(
           stringr::str_detect(decisao, regex_parcialmente_provido) ~ "Parcialmente Provido",
           stringr::str_detect(decisao, regex_provido) ~ "Provido",
           stringr::str_detect(decisao, regex_nao_provido) ~ "Improvido",
           stringr::str_detect(decisao, regex_nao_conheceram) ~ "Não Conheceram",
           TRUE ~ "Outros"
         ),
         decisao_binaria = ifelse(resultado == "Improvido", "Improvido", "Provido"))
```


```{r}
d_infos %>% 
  filter(resultado == "Outros") %>% 
  View
```

## Análises descritivas das explicativas versus a resposta

```{r}
d_infos %>% 
  count(decisao_binaria, assunto_geral) %>% 
  mutate(assunto_geral = str_wrap(assunto_geral, 15)) %>%
  ggplot(aes(y = n, x = assunto_geral, fill = decisao_binaria)) +
  geom_bar(stat = 'identity', position = 'fill')
```

```{r}
d_infos %>% 
    count(decisao_binaria, extraordinaria) %>% 
    ggplot(aes(y = n, x = extraordinaria,
               fill = decisao_binaria)) +
    geom_bar(stat = 'identity', position = 'fill')
```

```{r}
d_infos %>%
  mutate(duracao = dmy(data_da_ultima_decisao) - data_de_distribuicao,
         duracao = as.numeric(duracao),
         duracao = cut(duracao, breaks = 10, include.lowest = T, dig.lab = 3)) %>% 
  count(decisao_binaria, duracao) %>% 
  ggplot(aes(y = n, x = duracao, fill = decisao_binaria)) +
  geom_bar(stat = 'identity', position = 'fill') +
  theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1))
```

```{r}
d_infos %>%
  ggplot(aes(x = duracao, fill = decisao_binaria)) +
  geom_density(alpha = 0.5) +
  coord_cartesian(xlim=c(0, 1000)) 
  #+ facet_wrap(~decisao_binaria)
```



```{r}
# visualizar os assuntos com maior quantidade de resultados 
# positivos
d_infos %>%
  mutate(assunto = assunto %>% as.factor() %>% fct_lump(n = 10)) %>%
  group_by(assunto) %>%
  summarise(
    qtd_processos = n(),
    perc_provido = mean(decisao_binaria == "Provido")
  ) %>%
  mutate(assunto = assunto %>% str_wrap(width = 20) %>% fct_reorder(perc_provido)) %>%
  gather(var, valor, -assunto) %>%
  ggplot(aes(x = assunto, y = valor)) + 
  geom_col() + 
  facet_wrap(~var, scales = "free", ncol = 1)
```


# Exercícios:

1) Identifique os relatores com mais decisoes "Provido" em quantidade e percentualmente.
2) Dependendo do assunto do processo a duração é diferente? Compare apenas entre os assuntos intermediários que mais acontecem.
3) Qual é o Foro com maior número de processos? 
4) Existe diferença no resultado do processo dependendo da classe? Faça um gráfico p/ apresentar os resultados.
5) Em geral os relatores se apresentam sempre na mesma Vara? Faça um gráfico p/ apresentar os resultados.
6) Existe diferença na duração dos processos entre as Comarcas? Faça um gráfico p/ apresentar os resultados.
7) Qual é o primeiro nome mais comum entre os relatores e revisores? Faça um gráfico p/ apresentar os resultados.
8) Qual é o número médio de palavras do texto da decisão por assunto? Faça um gráfico p/ apresentar os resultados.
9) Existem pares de revisores e relatores que analisaram mais de 10 processos juntos?
10) Quantos assuntos distintos são julgados em cada vara? Faça um gráfico p/ apresentar os resultados.



























# Anexos



```{r, eval = FALSE}
dataset <- readr::read_rds("data/d_cposg.rds")

informacoes <- dataset %>% 
  select(id, data) %>% 
  unnest(data) %>% 
  spread(data, value) %>% 
  janitor::clean_names() %>% 
  abjutils::rm_accent_from_names()

decisoes <- dataset %>% 
  select(id, decisions) %>% 
  unnest(decisions) %>% 
  group_by(id) %>%
  filter(date == max(date))

movs <- dataset %>% 
  select(id, movs) %>% 
  unnest(movs) %>% 
  mutate(movement = format(movement, "%d/%m/%Y"))
  #group_by(id) %>% 
  #Wsummarise(data_de_distribuicao = min(movement))

processos <- readRDS("../Aula 1/data/processos_pra_pegar.rds")

d_infos <- informacoes %>% 
  inner_join(decisoes) %>% 
  #inner_join(movs) %>% 
  filter(area == "Criminal",
         id %in% processos,
         !distribuicao %in% c("5ª Câmara de Direito Criminal D", "Órgão Especial"),
         situacao %in% c("Encerrado", "Julgado", "Transitado")
         # Tiramos o "administrativamente" porque são casos em que não há julgamento do mérito
         ) %>% 
  select(-x, -outros_numeros, -numeros_de_origem, -processo, -ultima_carga, -volume_apenso) %>% 
  rename(data_da_ultima_decisao = date,
         decisao = decision) %>% 
  mutate(data_da_ultima_decisao = format(data_da_ultima_decisao, "%d/%m/%Y")
         #data_de_distribuicao = format(data_de_distribuicao, "%d/%m/%Y")
  )

saveRDS(d_infos, 'data/infos_processos.rds')
saveRDS(movs,  'data/movs_processos.rds')
```
